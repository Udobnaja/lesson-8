# Архитектура

DEMO: https://udobnaja.github.io/lesson-8/

## Команды

Поставить зависимости `npm install` <br>

Скорее всего для ts придется запусть команду `tsc index ts` в папке app 
(у меня не получилось так, чтобы Webpack это ел без лишних телодвижений)

Запустить проект `npm run start` <br>
Собрать проект `npm run build` <br>
Или собрать в деве `npm run build:dev` <br>
Деплой проекта `npm run deploy` <br>
Линт проекта `npm run lint` <br>
(МОжно запускать отдельно как для sass, так и для ts `lint:sass` и `lint:ts`, а так же фикс `lint:fix`)

### Описание работы и мысли

Папка app/src содержит ресурсы

Папка app/services задел на все возможные сервисы, например, для отправки данных на сервер.

Есть только FLUX и MVP

**FLUX** -> VIEW создает событие -> создаются ACTION -> диспетчер делает DISPATCH -> STORE выполняется всю логику (т.е никакого взаимодействий напрямую со стором
как в примере Flux для глупых людей, никаких изменений извне) -> по завершению кидает ChangeEvent, через который меняется состояние в STORE и при выполнение которого, VIEW получают сигнал,
что пора перерендериться.

Сама реализация архитектуры лежит в папке modules, как если бы у нас были реальные модули в node_modules, а реализация - в папке app
(в ней есть тоже папка modules, которая повторяет структуру модулей)

Что мне не нравится в моей реализации: у меня есть класс Log и HTMLLog и все модули их экстендят,
хотелось сделать базовый класс и его расширять кассами логера (чтобы был чистый класс Store, StoreWithLog, StoreHTMLLogger), т.е мне очень хотелось делать extend от двух классов,
решения с миксинами, которы я нашла в интернете - мне не как то не подошли, либо я их не докрутила.

Рендер VIEW для FLUX способен выдержать только один уровень, с вложенностями он работать не будет, но для реализации этого должно быть достаточно.
data-bind не будет работать для двух, data-disabled - только для разных tagName - все это лишь для показа работы приложения.
Если Очень захотеть отписать от диспач события, нужно постараться, нужно знать тип события и индекс его в массиве типов этого события,
что как бы очень не удобно =/

Store сделан через приватный конструктор, но мне очень уж хотелось попробовать эту реализацию,
в то время как Dispatcher тоже синглтон, он реализован по-другому, его можно вызывать несколько раз с ключевым словом new
но инстанс мы будем получать одного и того же объекта.

Операция sendToServer асинхронная - поэтому будет задержка, пока что-то появится в логах (так же и для MVP)

**MVP**

Как я поняла работает MVP -> VIEW создает какое-то событие, PRESENTER -> на него реагирует и решает что ему делать ->
например выполнить методы MODEL (т.е MODEL содержит всю бизнес логику, общение с сервером итд) -> когда MODEL выполнит свою часть -> PRESENTER
обновляет состояние MODEL и решает обновлять ли ему VIEW (то етсь он некая связка между этими двумя частями)

Красиво сделать не получилось, нет красивого интерфейса создания, все равно приходиться создавать классы, которые экстендят базовые и
переписывают там логику, постаралась это сделать как можно прозрачней (везде убрала конструкторы с super и uldate выполняется через сеттеры, есть что-то вроде хука init у PRESENTER),
но не знаю вышло ли. View имеет метод provider, для подстановки своих
PRESENTER и MODEL.
Мне кажется он какой-то очень в лоб и зависимый получился.

Задание интересное, но голову поломало =)



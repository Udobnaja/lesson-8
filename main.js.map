{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./modules/log/index.ts","webpack:///./modules/observer/index.ts","webpack:///./modules/flux/store/index.ts","webpack:///./modules/flux/dispatcher/index.ts","webpack:///./app/actions/input.ts","webpack:///./app/actions/data.ts","webpack:///./app/actions/button.ts","webpack:///./app/store/index.ts","webpack:///./app/services/data.ts","webpack:///./modules/flux/view/index.ts","webpack:///./app/views/log.ts","webpack:///./app/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","messageType","Logger","[object Object]","message","type","ERROR","console","error","log","HTMLLogger","super","this","_HTMLNode","document","querySelector","HTMLNode","innerHTML","Observable","_value","observers","notifyObservers","observer","push","splice","indexOf","arg","forEach","update","store_TYPE","store_Store","_state","state$","_instance","Error","dispatcher","state","callbacks","INFO","key","register","next","getValue","payload","keys","length","assign","dispatcher_TYPE","dispatcher_Dispatcher","_callbacks","Map","callback","has","set","action","index","INPUT_TYPE","DATA_TYPE","BUTTON_TYPE","store_dispatcher","store_store","createStore","logList","currentData","data","dispatch","changeEvent","Promise","resolve","reject","id","setTimeout","clearTimeout","sendToServer","then","catch","e","view_TYPE","node","_observable","registerObserver","childNodes","dataset","bind","undefined","innerText","template","_render","render","app_input","app_button","app_dispatcher","addEventListener"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export enum messageType {\n    INFO,\n    ERROR\n}\n\nexport interface ILog {\n     log(message: string, type: messageType): void;\n}\n\nexport class Logger implements ILog {\n    log(message, type){\n        if (type === messageType.ERROR){\n            console.error(message);\n        } else {\n            console.log(message);\n        }\n    }\n}\n\n// по умолчанию .log\n// но можно переопределить\n\nexport class HTMLLogger extends Logger {\n    private _HTMLNode;\n\n    constructor(){\n        super();\n        this._HTMLNode = document.querySelector('.log');\n    }\n\n    set HTMLNode(value) {\n        //check value  not empty\n        this._HTMLNode = value;\n    }\n\n   log(message, type){\n        super.log(message, type);\n        if (this._HTMLNode){\n            this._HTMLNode.innerHTML += `${message} <br>`;\n        }\n    }\n}","export interface Observer {\n    update (arg:any);\n}\n\nexport class Observable {\n    private observers : Observer [];\n    private _value;\n\n    constructor(value) {\n        this._value = value;\n        this.observers = [];\n    }\n\n\n    public next(value){\n        this._value = value;\n        this.notifyObservers(value);\n    }\n\n    public getValue(){\n        return this._value;\n    }\n\n    public registerObserver (observer : Observer) : void {\n        this.observers.push(observer);\n    }\n\n    public removeObserver (observer : Observer) : void {\n        this.observers.splice(this.observers.indexOf(observer), 1);\n    }\n\n    private notifyObservers (arg : any) : void {\n        this.observers.forEach((observer : Observer)=> {\n            observer.update(arg);\n        });\n    }\n}","import {Dispatcher} from \"../dispatcher/index\";\nimport {messageType, HTMLLogger} from \"../../log/index\";\nimport {Observable} from \"../../observer/index\";\n\nconst TYPE = 'STORE';\n\nexport class Store extends HTMLLogger {\n\n    private constructor() {\n        super();\n\n        Store._state = new Observable({});\n        this.state$ = Store._state;\n\n        if (Store._instance) {\n            throw new Error(\"only one Store is Allowed\");\n        }\n    }\n\n    protected static _instance: Store = new Store;\n    protected static dispatcher: Dispatcher;\n\n    protected static _state:Observable;\n    public state$:Observable;\n\n    public static createStore({\n        dispatcher,\n        state,\n        callbacks\n    }){\n        Store._instance.log(`${TYPE} WAS CREATED`, messageType.INFO);\n        Store.dispatcher = dispatcher;\n\n        for (let key in callbacks){\n            this.dispatcher.register(key, callbacks[key]);\n        }\n\n        Store._state.next(state);\n\n        return this._instance;\n    }\n\n    get state() {\n        return Store._state.getValue();\n    }\n\n    changeEvent(payload) {\n        const keys = Object.keys(payload);\n        const log = (keys.length) ? `${TYPE} CHANGE ${keys} KEYS` : '${TYPE} CHANGE EVENT FIRED WITH EMPTY PAYLOAD';\n        this.log(log, messageType.INFO);\n        if (keys.length){ // для того чтобы рендер выполнялся только при наличии payload\n            Store._state.next(Object.assign(this.state, payload));\n        }\n    }\n}\n\n","import {IAction} from \"../action/index\";\nimport {messageType, HTMLLogger} from \"../../log/\";\n\nconst TYPE = 'DISPATCHER';\n\nexport class Dispatcher extends HTMLLogger {\n    constructor() {\n\n        if (Dispatcher._instance){\n            return Dispatcher._instance;\n        }\n        super();\n        this._callbacks = new Map();\n    }\n\n    private _callbacks;\n    protected static _instance: Dispatcher = new Dispatcher;\n\n    register(type: string, callback:Function){\n\n        if (!this._callbacks.has(type)){\n            this._callbacks.set(type, []);\n        }\n\n        this._callbacks.get(type).push(callback);\n\n        this.log(`${TYPE} REGISTER ${type} CALLBACK`, messageType.INFO);\n    }\n\n    dispatch(action: IAction<any>) {\n        \n        if (this._callbacks.has(action.type)){\n            this._callbacks.get(action.type).forEach((callback) =>  {\n                this.log(`${TYPE} DISPATCH ${action.type} CALLBACK`, messageType.INFO);\n                callback(action.payload);\n            });\n        } else {\n            this.log(`${TYPE} DISPATCH ERRORS ON TYPE ${action.type} CALLBACK`, messageType.ERROR);\n        }\n    }\n\n    unregister(type, index:number){\n        if (this._callbacks.has(type)){\n            const callbacks = this._callbacks.get(type);\n            if (index < callbacks.length && index >= 0){\n                this._callbacks.get(type).splice(index, 1);\n                this.log(`${TYPE} UNREGISTER ${type} CALLBACK with index ${index}`, messageType.INFO);\n            }\n        }\n    }\n}\n","export const INPUT_TYPE = {\n   'CLICK': 'INPUT_CLICK',\n   'KEYUP': 'INPUT_ON_KEY_UP'\n};\n\n\n// Первое представление","export const DATA_TYPE = {\n    'SEND_DATA': 'DATA_IN_SEND_PROCESS',\n    'SEND_SUCCESS': 'DATA_WAS_SENT',\n    'SEND_ERROR': 'ERROR_DATA',\n};","export const BUTTON_TYPE = {\n    'CLICK': 'BUTTON_CLICK',\n};","import {Store} from \"../../modules/flux/store/index\";\nimport {Dispatcher} from \"../../modules/flux/dispatcher/index\";\nimport {INPUT_TYPE, DATA_TYPE, BUTTON_TYPE} from \"../actions/\";\nimport {sendToServer} from \"../services/data\";\nconst dispatcher = new Dispatcher();\nconst state = {\n    log: '',\n    logList: [],\n    currentData: '',\n    data: 'Здесь появится ответ сервера'\n};\n\nexport const store = Store.createStore({\n    dispatcher,\n    state,\n    callbacks: { // mutations\n        [BUTTON_TYPE.CLICK]: () => {\n            dispatcher.dispatch({type: DATA_TYPE.SEND_DATA});\n            //store.changeEvent({}); // может не стоит передовать стору пустые значения,\n        },\n        [INPUT_TYPE.KEYUP]: (payload) => {\n            store.changeEvent({currentData: payload}); //  мутирем стор только через change Event\n        },\n        [DATA_TYPE.SEND_DATA]: () => {\n            sendToServer(store.state.currentData).then((data) => {\n                dispatcher.dispatch({type: DATA_TYPE.SEND_SUCCESS, payload: (data) ? data : 'YOU SEND EMPTY DATA'});\n                // store.changeEvent({});\n            }).catch((e) => {\n                dispatcher.dispatch({type: DATA_TYPE.SEND_ERROR});\n                // store.changeEvent({});\n            })\n\n        },\n        [DATA_TYPE.SEND_SUCCESS]: (payload) => {\n            store.changeEvent({data: payload});\n        }\n    },\n});\n","const TIMEOUT = 800;\n\nconst sendToServer = (data) => {\n    // Выполняется какая то асинхронная операция\n\n    return new Promise((resolve, reject) => {\n        let id = setTimeout(() => {\n            resolve(data);\n            clearTimeout(id);\n        }, TIMEOUT);\n        // reject() if\n    });\n};\n\nexport { sendToServer }","import {HTMLLogger, messageType} from \"../../log/index\";\nimport {Observer, Observable} from \"../../observer/index\";\nconst TYPE = 'VIEW';\nexport class View extends HTMLLogger implements Observer {\n\n    private template;\n    private keys = {};\n\n    constructor(private node, private _observable: Observable){\n        super();\n        this.node = node;\n        this._observable = _observable;\n        this._observable.registerObserver(this);\n\n    }\n\n    private _render(state){\n        // Не живой пример - проходимся только по узлам первой вложенности\n        for (let node of this.node.childNodes){\n           // сохраняем ключи и сравниваем изменились они или нет и если изменились делать рендер\n           const key = node.dataset.bind;\n\n           if (key !== undefined){\n               if (this.keys[key] === undefined || state[key] !== this.keys[key]){\n                   this.log(`${TYPE} RENDER`, messageType.INFO);\n                   node.innerText = state[key];\n                   this.keys[key] = state[key];\n               }\n           }\n        }\n    }\n\n    public render(callback){\n        this.template = callback();\n        this.node.innerHTML = this.template;\n        this._render(this._observable.getValue());\n    }\n\n    update(state){\n        this._render(state);\n    }\n}","import {store} from \"../store/index\";\nimport {View} from \"../../modules/flux/view/index\";\n\nconst label = document.querySelector('.view-stub__label');\nconst LogNode = new View(label, store.state$);\n\nLogNode.render(() => {\n    return `<div data-bind=\"data\"></div>`\n});\n\nexport {LogNode};","import './styles.scss';\nimport './views/log';\nimport './store/';\n\nimport {Dispatcher} from '../modules/flux/';\nimport {INPUT_TYPE, BUTTON_TYPE} from './actions/';\n\nconst input = document.querySelector('input');\nconst button = document.querySelector('.view-stub__apply');\n\nconst dispatcher = new Dispatcher(); //  можно создать через new, но он все равно SingleTone\n\nbutton.addEventListener('click', () => {\n    dispatcher.dispatch({type: BUTTON_TYPE.CLICK}); // payload необязательный\n});\n\ninput.addEventListener('keyup', function(){\n    dispatcher.dispatch({type: INPUT_TYPE.KEYUP, payload: this.value});\n});\n\n\n"],"sourceRoot":""}